#pragma once

/*
	第13章  拷贝控制
*/
namespace copy_assignment
{
	// 如果一个构造函数第一个参数是自身类类型的引用，
	// 且任何额外参数都有默认值，则此构造函数是拷贝构造函数
	// 拷贝构造函数第一个参数必须是一个引用类型，否则会陷入无限递归中
	// 拷贝构造函数在几种情况下都会被隐式地使用，因此拷贝构造函数通常不应该是explicit的
	class Foo
	{
	public:
		Foo() = default; // 默认构造函数
		Foo(const Foo&) = delete; // 禁用拷贝构造函数
		Foo& operator=(const Foo&); // 赋值运算符：通常应该返回一个指向其左侧运算对象的引用
		// 如果一个类未定义自己的靠背赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

		// 析构函数不接受参数，因此它不能被重载。一个给定类只会有唯一一个析构函数
		// 析构函数自身并不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的
		// 在整个对象销毁过程中，析构函数是作为成员销毁步骤之外的另一部分而进行的
		// 我们不能删除析构函数。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类型的临时变量。 
		// 而且如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象
		// 对于删除了析构函数的类型，们虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象
		// 但是，不能释放这些对象(不能用delete)
		~Foo() = default;

		/*
			三/五法则：
			三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝复制运算和析构函数
			在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值函数

			当我们能决定一个类是否要定义它自己版本的拷贝控制成员时，
			一个基本原则是首先确定这个类是否需要一个析构函数
			如果这个类需要一个析构函数，几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值函数

		*/
	};
	
};

